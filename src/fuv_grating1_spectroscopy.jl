
#using FITSIO, Dierckx, Measurements,  DelimitedFiles, SmoothingSplines, Dates

"""
   `fuv_grating1_count_spec(fuv_grating1_image_file, ds9regfile[, order = -1, angle_xaxis_disp_deg=0.0, cross_disp_width_pixels = 40, rate = true])` 

Extract count rate spectrum from AstroSat/UVIT FUV-Grating1 dispersed image generated from CCDLAB processing pipeline.

...
# Arguments
## Required parameters
- `fuv_grating1_image_file::String`: Name of the FUV-Grating1 image file in FITS format generated using CCDLAB.
- `ds9regfile::String`: Name of the ds9 region file with center as the zero order position.
## Optional parameters
- `order::Int`: -2 (default), Grating order to be used to extract the spectrum. 
                 Allowed orders=-1 and -2.
- `angle_xaxis_disp_deg`: 0.0 (default), angle between dispersion axis and x-axis.
- `cross_disp_width_pixels::String`: 40 (default), width in pixels in the cross-dispersion direction.
- `rate::Bool`: true (default) for count rate spectrum, otherwise false for count spectrum.
## Output
- count spectrum file
- region file compatible with ds9 that can be used to verify the extraction region for requested order.
- Count spectrum as (pixel numbers relative to zero order, counts/s or counts, errors)
...
"""
function fuv_grating1_count_spec(fuv_grating1_image_file::String, ds9regfile::String; order::Int = -2, angle_xaxis_disp_deg::Float64=0.0, cross_disp_width_pixels::Int = 40, rate::Bool = true)
#Open grating image file generated by CCDLAB
   	fb = FITS(fuv_grating1_image_file)
   	gimg = read(fb[1])
   	exposure_time_sec = float(read_key(fb[1], "RDCDTIME")[1])
   	uvit_detector = read_key(fb[1], "DETECTOR")[1]
   	uvit_grating = read_key(fb[1], "FILTERID")[1]
   	naxis1 = read_key(fb[1], "NAXIS1")[1]

# Extract 1d spectrum

#Extract source x/y center from ds9 region file
   	(cenx, ceny) = xycen_from_ds9reg(ds9regfile)

# Determine the trace and cross-dispersion range for spectral extraction

# Trace is linear line : y =mx+c with m=tand(267.531) for FUV grating1
#The slope and intercept are

    m = tand(angle_xaxis_disp_deg)
    c = ceny - m * cenx

# Need to find x-coordinate along the trace i.e., for each y.
# Number of rows i.e., number of y values is naxis2.

    xvals = collect(1:naxis1)
    yvals = round.(Int, (m * xvals .+ c))
#println(xvals)

   	ylo = round.(Int, yvals .- cross_disp_width_pixels / 2)
	#println(xlo)
   	yhi = round.(Int, yvals .+ cross_disp_width_pixels / 2)
	#println(xhi)

	# Sum the counts from xlo to xhi for each xvalue

   	grating_spec = sum.([gimg[i, ylo[i]:yhi[i]] for i in 1:naxis1])


	#pixel_numbers = linearindices(src_spec)
 	#pixel_numbers = range(1,1,length(grating_spec))
   	pixel_numbers = collect(1:length(grating_spec))
   	pixel_num_wrt_zero_order =  pixel_numbers .- round(Int, cenx)



# Select the range of pixel numbers wrt zero order appropriate for -2 or -1 order
    if order == -2
		#1280 to 1800A corresponds to -630 to -442 in order=-2
       	pixels_m2_order = pixel_num_wrt_zero_order[(pixel_num_wrt_zero_order .> -630) .& (pixel_num_wrt_zero_order .< -412)]
       	grating_spec_m2_order = grating_spec[(pixel_num_wrt_zero_order .> -630) .& (pixel_num_wrt_zero_order .< -412)]
       	grating_spec_m2_order_counts = measurement.(grating_spec_m2_order, sqrt.(grating_spec_m2_order))
       	grating_spec_m2_order_counts_per_s =  grating_spec_m2_order_counts / exposure_time_sec
	# generate extraction region that can be displayed in ds9
		xcen_m2 = (-629 - 413)/2 + cenx
		ycen_m2 = m * xcen_m2 +  c
		xsize_m2 = -413 + 629 + 1
		ysize_m2 = cross_disp_width_pixels
	#	println([xcen_m2, ycen_m2, xsize_m2, ysize_m2])
		reg = """# Region file format: DS9 version 4.1
		global color=green dashlist=8 3 width=1 font="helvetica 10 normal roman" select=1 highlite=1 dash=0 fixed=0 edit=1 move=1 delete=1 include=1 source=1
		physical
		box($xcen_m2,$ycen_m2,$xsize_m2,$ysize_m2,$angle_xaxis_disp_deg)
		"""
	# 	Construct and write region filename from input zero order region file
		outregfile = split(ds9regfile, ".")[1] * "_fuv_grating1_m2" * ".reg"
		open(outregfile, "w") do file
			write(file, reg)
		end
	#	Construct and write output 1d count spectrum file
		outspecfile = split(ds9regfile, ".")[1] * "_fuv_grating1_m2_count_spec" * ".dat"
        if rate == true
		#display(plot(pixels_m2_order, Measurements.value.(grating_spec_m2_order_counts_per_s), yerr=Measurements.uncertainty.(grating_spec_m2_order_counts_per_s),xlabel="Pixel numbers wrt zero order", ylabel="counts/s"))
          		writedlm(outspecfile, zip(pixels_m2_order, Measurements.value.(grating_spec_m2_order_counts_per_s), Measurements.uncertainty.(grating_spec_m2_order_counts_per_s)))
          		return pixels_m2_order, grating_spec_m2_order_counts_per_s
       	else
		#display(plot(pixels_m2_order, Measurements.value.(grating_spec_m2_order_counts), yerr=Measurements.uncertainty.(grating_spec_m2_order_counts), xlabel="Pixel numbers wrt zero order", ylabel="counts"))
          		writedlm(outspecfile, zip(pixels_m2_order, Measurements.value.(grating_spec_m2_order_counts), Measurements.uncertainty.(grating_spec_m2_order_counts)))
          		return pixels_m2_order, grating_spec_m2_order_counts
       	end
		
		

    elseif order == -1
	
		#= Original code
       	pixels_m1_order = pixel_num_wrt_zero_order[(pixel_num_wrt_zero_order .> -322) .& (pixel_num_wrt_zero_order .< -212)]
       	grating_spec_m1_order = grating_spec[(pixel_num_wrt_zero_order .> -322) .& (pixel_num_wrt_zero_order .< -212)]
		=# 

		# Modified to extract wider wavelength coverage to check red leak
		pixels_m1_order = pixel_num_wrt_zero_order[(pixel_num_wrt_zero_order .> -401) .& (pixel_num_wrt_zero_order .< -212)]
       	grating_spec_m1_order = grating_spec[(pixel_num_wrt_zero_order .> -401) .& (pixel_num_wrt_zero_order .< -212)]
       	grating_spec_m1_order_counts = measurement.(grating_spec_m1_order, sqrt.(grating_spec_m1_order))
       	grating_spec_m1_order_counts_per_s =  grating_spec_m1_order_counts / exposure_time_sec
        # generate extraction region that can be displayed in ds9
		xcen_m1 = (-400 - 213)/2 + cenx
		ycen_m1 = m * xcen_m1 +  c
		xsize_m1 = -213 + 400 + 1
		ysize_m1 = cross_disp_width_pixels
		reg_m1 = """# Region file format: DS9 version 4.1
		global color=green dashlist=8 3 width=1 font="helvetica 10 normal roman" select=1 highlite=1 dash=0 fixed=0 edit=1 move=1 delete=1 include=1 source=1
		physical
		box($xcen_m1,$ycen_m1,$xsize_m1,$ysize_m1,$angle_xaxis_disp_deg)
		"""
		# Construct output DS9 region file 
		outregfile = split(ds9regfile, ".")[1] * "_fuv_grating1_m1" * ".reg"
		open(outregfile, "w") do file
			write(file, reg_m1)
		end
		outspecfile = split(ds9regfile, ".")[1] * "_fuv_grating1_m1_count_spec" * "_cross_disp_with_" * string(cross_disp_width_pixels) * "pixels_" * string(angle_xaxis_disp_deg) * "deg.dat"
		if rate == true
		#display(plot(pixels_m2_order, Measurements.value.(grating_spec_m2_order_counts_per_s), yerr=Measurements.uncertainty.(grating_spec_m2_order_counts_per_s),xlabel="Pixel numbers wrt zero order", ylabel="counts/s"))
          	writedlm(outspecfile, zip(pixels_m1_order, Measurements.value.(grating_spec_m1_order_counts_per_s), Measurements.uncertainty.(grating_spec_m1_order_counts_per_s)))
          	return pixels_m1_order, grating_spec_m1_order_counts_per_s
       	else
		#display(plot(pixels_m2_order, Measurements.value.(grating_spec_m2_order_counts), yerr=Measurements.uncertainty.(grating_spec_m2_order_counts), xlabel="Pixel numbers wrt zero order", ylabel="counts"))
          		writedlm(outspecfile, zip(pixels_m1_order, Measurements.value.(grating_spec_m1_order_counts), Measurements.uncertainty.(grating_spec_m1_order_counts)))
          		return pixels_m1_order, grating_spec_m1_order_counts
       	end
		
  		else
   				 println("Grating order $order not calibrated")
			 end
end

# Function to calculate net count rate for grating order -2 or -1


"""
    fuv_grating1_net_countrate_spec(fuv_grating1_image_file::String, ds9srcregfile::String, ds9bgdregfile::String; order::Int = -2, angle_xaxis_disp_deg::Float64=0.0, cross_disp_width_pixels::Int = 40)


   `fuv_grating1_net_countrate_spec(fuv_grating1_image_file, ds9srcregfile, ds9bgdregfile[, order = -2, angle_xaxis_disp_deg=0.0, cross_disp_width_pixels = 40])` 

Extract background corrected, net count rate spectrum from AstroSat/UVIT FUV-Grating1 dispersed image generated from CCDLAB processing pipeline.

...
# Arguments
## Required parameters
- `fuv_grating1_image_file::String`: Name of the FUV-Grating1 image file in FITS format generated using CCDLAB.
- `ds9srcregfile::String`: Name of the ds9 region file with source center as the zero order position.
- `ds9bgdregfile::String`: Name of the ds9 region file with  center in a source-free region of the image.
## Optional parameters
- `order::Int`: -2 (default), Grating order to be used to extract the spectrum. 
                 Allowed orders=-1 and -2.
- `angle_xaxis_disp_deg`: 0.0 (default), angle between dispersion axis and x-axis.
- `cross_disp_width_pixels::Int`: 40 (default), width in pixels in the cross-dispersion direction.
## Output
- DS9 Region files used for extraction source and background count spectra.
- Source and background count spectra in ascii files.
...
"""
function fuv_grating1_net_countrate_spec(fuv_grating1_image_file::String, ds9srcregfile::String, ds9bgdregfile::String; order::Int = -2, angle_xaxis_disp_deg::Float64=0.0, cross_disp_width_pixels::Int = 40)
   	if order == -2 || order == -1
     	(pixels, src_spec_counts_per_s) = fuv_grating1_count_spec(fuv_grating1_image_file, ds9srcregfile,  order = order,  angle_xaxis_disp_deg=angle_xaxis_disp_deg, cross_disp_width_pixels = cross_disp_width_pixels, rate = true)
       	(pixels, bgd_spec_counts_per_s) = fuv_grating1_count_spec(fuv_grating1_image_file,  ds9bgdregfile, order = order, angle_xaxis_disp_deg=angle_xaxis_disp_deg, cross_disp_width_pixels = cross_disp_width_pixels, rate = true)
		netsrc_spec_counts_per_s = (src_spec_counts_per_s .- bgd_spec_counts_per_s)
		if order == -2
			outfile = "net_fuv_grating1_" * "m2" * "_countrate_spec" * "_cross_disp_with_" * string(cross_disp_width_pixels) * "pixels_" * string(angle_xaxis_disp_deg) * "deg.dat"
		else
			outfile = "net_fuv_grating1_" * "m1" * "_countrate_spec" * "_cross_disp_with_" * string(cross_disp_width_pixels) * "pixels_" * string(angle_xaxis_disp_deg) * "deg.dat"
		end
	 	writedlm(outfile, zip(pixels, Measurements.value.(netsrc_spec_counts_per_s), Measurements.uncertainty.(netsrc_spec_counts_per_s)))
 	 else
     	println("Grating order $order not calibrated")
 	 end
 		 return pixels, netsrc_spec_counts_per_s
end

"""
    fuv_grating1_net_countrate(fuv_grating1_image_file::String, ds9srcregfile::String, ds9bgdregfile::String; order::Int = -2, angle_xaxis_disp_deg::Float64=0.0, cross_disp_width_pixels::Int = 40, mst_or_bjd="mst")


   `fuv_grating1_net_countrate(fuv_grating1_image_file, ds9srcregfile, ds9bgdregfile[, order = -2, angle_xaxis_disp_deg, cross_disp_width_pixels = 40])` 

Calculate background corrected, net count rate from AstroSat/UVIT FUV-Grating1 dispersed image generated from CCDLAB processing pipeline.

...
# Arguments
## Required parameters
- `fuv_grating1_image_file::String`: Name of the FUV-Grating1 image file in FITS format generated using CCDLAB.
- `ds9srcregfile::String`: Name of the ds9 region file with source center as the zero order position.
- `ds9bgdregfile::String`: Name of the ds9 region file with  center in a source-free region of the image.
## Optional parameters
- `order::Int`: -2 (default), Grating order to be used to extract the spectrum. 
                 Allowed orders=-1 and -2.
- `angle_xaxis_disp_deg`: 0.0 (default), angle between dispersion axis and x-axis.
- `cross_disp_width_pixels::String`: 40 (default), width in pixels in the cross-dispersion direction.
- `mst_or_bjd::String`: Print mission time (mst) or barycentric julain data (bjd). Default: "mst".
## Output
- Net count rate
...
"""
function fuv_grating1_net_countrate(fuv_grating1_image_file::String, ds9srcregfile::String, ds9bgdregfile::String; order::Int = -2, angle_xaxis_disp_deg::Float64=0.0, cross_disp_width_pixels::Int = 40, mst_or_bjd="mst")
		fb = FITS(fuv_grating1_image_file)
	#	gimg = read(fb[1])
		exposure_time_sec = float(read_key(fb[1],"RDCDTIME")[1])
		uvit_detector = read_key(fb[1],"DETECTOR")[1]
		uvit_grating = read_key(fb[1],"FILTERID")[1]
		if mst_or_bjd=="mst"
			tstart = read_key(fb[1],"TSTART")[1]
			tstop = read_key(fb[1],"TSTOP")[1]
			meanmst=(tstart + tstop) / 2.0
		elseif mst_or_bjd=="bjd"
			meanbjd=read_key(fb[1],"MEANBJD")[1]
		else
			println("The value of keyword mst_or_bjd is not one of mst or bjd.")
		end
		close(fb)

	if order == -2 || order == -1
		(pixels, src_spec_counts) = fuv_grating1_count_spec(fuv_grating1_image_file, ds9srcregfile,  order = order, angle_xaxis_disp_deg=angle_xaxis_disp_deg, cross_disp_width_pixels = cross_disp_width_pixels, rate = false)
		(pixels, bgd_spec_counts) = fuv_grating1_count_spec(fuv_grating1_image_file,  ds9bgdregfile, order = order, angle_xaxis_disp_deg=angle_xaxis_disp_deg, cross_disp_width_pixels = cross_disp_width_pixels, rate = false)
		total_src_counts = sum(src_spec_counts) 
		total_bgd_counts = sum(bgd_spec_counts)
		netsrc_count_rate = (total_src_counts - total_bgd_counts)/exposure_time_sec
	
	# Print result	
		println("")
		println("=====Calculating net count rate=====")
		println("UVIT Channel: $uvit_detector")
		println("Grating: $uvit_grating")
		println("Grating order= $order")
		println("Net source count rate= $netsrc_count_rate")
		if mst_or_bjd=="mst"
			println("Mission time: $meanmst")
			println("===================================")
			return meanmst, netsrc_count_rate
		else mst_or_bjd=="bjd"
			println("BJD= $meanbjd")
			println("===================================")
			return meanbjd, netsrc_count_rate
		end
		
	else
		println("Grating order $order not calibrated")
		return 0.0
 	 end
end


"""
   `fuv_grating1_pixel2lamA(pixel_num_wrt_zero_order[, order = -2])`

Convert pixel number relative to zero to wavelength in Angstrom.

This function is used for wavelength calibration of FUV-Grating1 count spectrum.
	
## Required parameters
- `pixel_num_wrt_zero_order::Int`: Pixel numbers relative to zero order.
## Optional parameters
- `order::Int`: -2 (default), Grating order. Allowed orders=-1 and -2.
...
"""
function fuv_grating1_pixel2lamA(pixel_num_wrt_zero_order;order=-2)
	pixels = pixel_num_wrt_zero_order
	if order == -2
	 
	 # Quadratic fit
	 #=
	 	(c0,c1, c2)=(-86.37260596120976, -3.2915660227689907, -0.00047561073304810747)
	 	fuv_lambdaA = c0 + c1* pixels + c2 * pixels^2
	=#

	# Linear fit
	 (c0,c1) = (45.52709688716913,-2.789558814560311)
	 fuv_lambdaA = c0 + c1* pixels
		return fuv_lambdaA
	elseif order == -1
		(c0,c1)=(-18.0335, -5.8332)
	 	fuv_lambdaA = c0 + c1* pixels
	#	netsrc_spec_counts_per_s_A = netsrc_spec_counts_per_s ./ 5.6046
		return fuv_lambdaA
	else
		println("Grating order=$order is not calibrated, wavelength calibration not available.")
		return -1
	end
end



"""
    lamA2lohi(lamA)
Generate wavelength bins (A_lo, A_hi) and energy bins (E_lo, E_hi) from an array of wavelengths in Å.

...
# Arguments
- `lamA::Array{Float64}`: An array of wavelengths in Å.

...
"""
function lamA2lohi(lamA::Array{Float64,1})
    sort!(lamA)
    nbins = length(lamA)
    lamA_lo = Array{Float64}(undef,nbins)
    lamA_hi = Array{Float64}(undef,nbins)


    for i=1:nbins
        if i==1
            lamA_lo[i] = lamA[i] - (lamA[i+1] - lamA[i])/2.0
            lamA_hi[i] = lamA[i] + (lamA[i+1] - lamA[i])/2.0
        elseif i < nbins
            lamA_hi[i] = lamA[i] + (lamA[i+1] - lamA[i])/2.0
            lamA_lo[i] = lamA_hi[i-1]
        else
            lamA_lo[i] = lamA_hi[i-1]
            lamA_hi[i] = lamA[i] + (lamA[i] - lamA[i-1])/2.0
    end

        println(lamA_lo[i])
       println(lamA_hi[i])
    end
    enkev_lo = reverse(lambdaA2keV.(lamA_hi))
    enkev_hi = reverse(lambdaA2keV.(lamA_lo))
    return lamA_lo, lamA_hi, enkev_lo, enkev_hi
end



"""
   `fuv_grating1_wavelength_calib(pixels, netsrc_spec_counts_per_s[, order = -2])`

Convert pixel numbers relative to zero order to wavelengths.

This function is used for wavelength calibration of FUV-Grating1 count spectrum.

...
# Arguments
## Required parameters
- `pixels::Array`: An array of pixel numbers relative to zero order.
- `netsrc_spec_counts_per_s::Array`: An array of net count rates corresponding to the relative pixel numbers.
## Optional parameters
- `order::Int`: -2 (default), Grating order. Allowed orders=-1 and -2.
...
"""
function fuv_grating1_wavelength_calib(pixels, netsrc_spec_counts_per_s; order = -2)
#Wavelength calibration analysis of NGC40 data in 1/8pixel resoultion
	fuv_lambdaA = fuv_grating1_pixel2lamA.(pixels,order=order)
    if order == -2
		# Generate wavelength grid in increasing wavelength order
		#(lo,hi) = lamA2lohi(fuv_lambdaA)
		# Reverse to decreasing order as fuv_lambdaA is in decreasing order
		# reverse!(lo)
		# reverse!(hi)
		netsrc_spec_counts_per_s_A = netsrc_spec_counts_per_s ./ 2.789558814560311
		return fuv_lambdaA, netsrc_spec_counts_per_s_A
    elseif order == -1
		netsrc_spec_counts_per_s_A = netsrc_spec_counts_per_s ./ 5.5690588440719395
		return fuv_lambdaA, netsrc_spec_counts_per_s_A
    else
		println("Grating order $order not calibrated.")
		return -1
    end

end

# gauss1d(x)  = ampl * exp(-4 * log(2) * (x - pos)^2 / fwhm^2)

"""
    fuv_grating1_ea(lamA[,order = -2])

Calculate effective area in cm^2 at a desired wavelength (Angstrom) and grating order -1 or -2.

The calculation of the effective area is based on the updated grating calibration using the procedures described in [Dewangan (2021)](https://ui.adsabs.harvard.edu/abs/2021JApA...42...49D/abstract). 
This function is used for flux calibration of count spectrum.

...
# Arguments
## Required
- `lam::Number`: Wavelength in Angstrom.
## Optional 
-`order::Int`: Grating order -1 or -2.
...

# Example
```jldoctest
julia> fuv_grating1_ea(1450.4,order=-2)
4.071442845470301
```
"""
function fuv_grating1_ea(lam; order = -2)
   	l = convert.(Float64, lam)
   	if order == -2

# Read effective area based on WD0308_crreject data
#f = FITS("/home/gulabd/work/julia_dev/UVITTools.jl/caldata/fuv_grating1m2_effarea_9nov22.fits")
f = FITS(joinpath(dirname(dirname(pathof(UVITTools))), "caldata", "fuv_grating1m2_effarea_9nov22.fits"))
ea_lamA = read(f[2], "X")
ea_cm2 = read(f[2],"MODEL")


	spl_ea = fit(SmoothingSpline, ea_lamA, ea_cm2, 1.0)
	ea = SmoothingSplines.predict(spl_ea, l)

	elseif order == -1
 		ea = 80994.70349982391  -311.9002643696168 * lam + 0.4993291773681191 * lam^2 -0.0004254619477234513 * lam^3 + 2.035223255254435e-07 * lam^4  -5.1823439777191215e-11 * lam^5 + 5.4873737910814825e-15 * lam^6
	else
    println("Grating order $order not calibrated.")
   	end
 		return ea
end


"""
   `fuv_grating1_flux_calib(lamA, netsrc_spec_counts_per_s_A[,order=-2])`

Flux calibrate the wavelength-calibrated count spectrum from FUV-Grating1.

This function calculates the effective area at each wavelength of the count spectrum, 
then uses the effective areas to convert net count rates to f_λ in CGS units.

...
# Arguments
## Required
-`lamA::Array{Float64}`: Array of wavelengths in Å.
-`netsrc_spec_counts_per_s_A::Array{Float64}`: Array of background corrected counts/s/Å corresponding to wavelength array.
## Optional
-`Order::Number`: Grating order -2 (default) or -1.

...
"""
function fuv_grating1_flux_calib(fuv_lambdaA, netsrc_spec_counts_per_s_A; order=-2)
	
	# Calculate the effective area from the best-fitting polynomial to the derived effective area
   	fuv_g1_ea_cm2_at_fuv_lambdaA = fuv_grating1_ea.(fuv_lambdaA, order=order)
# Calculate flux density
   	fuv_g1_n_λ = netsrc_spec_counts_per_s_A ./ fuv_g1_ea_cm2_at_fuv_lambdaA
   	fuv_g1_f_λ = fuv_g1_n_λ .* lambdaA2ergs.(fuv_lambdaA)
    return fuv_lambdaA, fuv_g1_f_λ
end

"""
    fuv_grating1_fluxed_spec(target,fuv_grating1_image_file, ds9srcregfile, ds9bgdregfile[, order = -2, angle_xaxis_disp_deg=0.0, cross_disp_width_pixels = 40])

Extract flux calibrated spectrum from AstroSat/UVIT FUV-Grating1 dispersed image generated from CCDLAB processing pipeline.

This is a main function that uses other functions for extraction of source and background spectra, wavelenth 
	and flux calibrations, and outputs fluxed spectrum. For details on grating orders, wavelength and flux calibrations, 
	see [Dewangan (2021)](https://ui.adsabs.harvard.edu/abs/2021JApA...42...49D/abstract).
...
# Arguments
## Required parameters
- `target::String`: Name of the target available in the observed UVIT field.
- `fuv_grating1_image_file::String`: Name of the FUV-Grating1 image file in FITS format generated using CCDLAB.
- `ds9srcregfile::String`: Name of the ds9 region file with source center as the zero order position.
- `ds9bgdregfile::String`: Name of the ds9 region file with  center in a source-free region of the image.
## Optional parameters
- `order::Int`: -2 (default), Grating order to be used to extract the spectrum. Allowed orders=-1 and -2.
- `angle_xaxis_disp_deg::Float64`: 0.0 (default), angle between dispersion axis and x-axis.
- `cross_disp_width_pixels::String`: 40 (default), width in pixels in the cross-dispersion direction.
## Output
- `(λ, f_λ, err_f_λ)`
- Fluxed spectrum saved in an ascii file.
- DS9 source and background region files used for spectral extraction.
- Source and background count spectral data in ascii files
- Net source count spectrum in ascii file
...
"""
function fuv_grating1_fluxed_spec(target::String,fuv_grating1_image_file::String, ds9srcregfile::String, ds9bgdregfile::String; order::Int = -2, angle_xaxis_disp_deg::Float64=0.0, cross_disp_width_pixels::Int = 50)
    (pixels, netsrc_spec_counts_per_s) = fuv_grating1_net_countrate_spec(fuv_grating1_image_file, ds9srcregfile, ds9bgdregfile, order=order, angle_xaxis_disp_deg = angle_xaxis_disp_deg, cross_disp_width_pixels = cross_disp_width_pixels)
   	(fuv_lambdaA, netsrc_spec_counts_per_s_A) = fuv_grating1_wavelength_calib(pixels, netsrc_spec_counts_per_s,order=order)
   	(fuv_lambdaA, f_lambda_with_error) = fuv_grating1_flux_calib(fuv_lambdaA, netsrc_spec_counts_per_s_A,order=order)
   	f_λ = Measurements.value.(f_lambda_with_error)
   	err_f_λ =  Measurements.uncertainty.(f_lambda_with_error)
  #display(plot(fuv_lambdaA,f_λ,yerr=err_f_λ,xlabel=L"Wavelength (\AA)", ylabel=L"f_\lambda (ergs cm^{-2} s^{-1}\AA{^-1})",ms=1, label="FUV Grating1"))
  #create output filename
  println("-----------------------------------")
  println("target=$target")
  fff = FITS(fuv_grating1_image_file)
  uvit_detector = read_key(fff[1], "DETECTOR")[1]
  println("UVIT channel=$uvit_detector")
  uvit_grating = read_key(fff[1], "FILTERID")[1]
  println("Grating=$uvit_grating")
  obsid = read_key(fff[1], "OBS_ID")[1]
  println("OBS_ID=$obsid")
  println("order=$order")
  exposure_time_sec = float(read_key(fff[1], "RDCDTIME")[1])
  println("Exposure time=$exposure_time_sec seconds")
  close(fff)
  println("---------------------------------------")
  if order==-1
      gorder="m1"
  elseif order==-2
      gorder="m2"
  else
      println("Grating order not calibrated")
	end
	# Make the spectrum in wavelength order
	reverse!(fuv_lambdaA)
	reverse!(f_λ)
	reverse!(err_f_λ)

  outfile = target * "_" * obsid * "_" * uvit_detector * "_" * uvit_grating * gorder * "_crossdisp" * string(cross_disp_width_pixels) * "pix_" * "xax_disp_" * string(angle_xaxis_disp_deg) * "deg_spec.dat"
    writedlm(outfile, zip(fuv_lambdaA, f_λ, err_f_λ))
    println("Wrote spectral ascii file: $outfile\n")
    return fuv_lambdaA, f_λ, err_f_λ
end


"""
    fuv_grating1_phafile(target,fuv_grating1_image_file, ds9srcregfile, ds9bgdregfile[,order = -2, angle_xaxis_disp_deg=0.0, cross_disp_width_pixels= 40])

Extract XSPEC/Sherpa compatible source and background PHA spectral files from AstroSat/UVIT FUV-Grating1 dispersed image generated from CCDLAB processing pipeline.

This function extracts source and background count spectra using the zero order positions provided 
in the DS9 region files and converts them into PHA spectral files. For details on grating orders 
and spectral responses, see [Dewangan (2021)](https://ui.adsabs.harvard.edu/abs/2021JApA...42...49D/abstract).

...
# Arguments
## Required parameters
- `target::String`: Name of the target available in the observed UVIT field.
- `fuv_grating1_image_file::String`: Name of the FUV-Grating1 image file in FITS format generated using CCDLAB.
- `ds9srcregfile::String`: Name of the ds9 region file with source center as the zero order position.
- `ds9bgdregfile::String`: Name of the ds9 region file with  center in a source-free region of the image.
## Optional parameters
- `order::Int`: -2 (default), Grating order to be used to extract the spectrum. Allowed orders=-1 and -2.
- `angle_xaxis_disp_deg::Float64`: 0.0 (default), angle between dispersion axis and x-axis.
- `cross_disp_width_pixels::Int`: 40 (default), width in pixels in the cross-dispersion direction.
#read necessary keywords`
## Output
- Source and background PHA files with RESPFILE key updated in the source spectral file
- Source and background DS9 region files used extract count spectra
- Source and Background count spectra in ascii files
- Net source count spectrum in ascii file
- Some relevant information are also printed on the screen.
...
"""
function fuv_grating1_phafile(target::String, fuv_grating1_image_file::String, ds9srcregfile::String, ds9bgdregfile::String; order::Int=-2, angle_xaxis_disp_deg::Float64=0.0, cross_disp_width_pixels::Int = 40)
	#read necessary keywords


  println("-----------------------------------")
  println("target=$target")
  fff = FITS(fuv_grating1_image_file)
  uvit_detector = read_key(fff[1], "DETECTOR")[1]
  println("UVIT channel=$uvit_detector")
  uvit_grating = read_key(fff[1], "FILTERID")[1]
  println("Grating=$uvit_grating")
  obsid = read_key(fff[1], "OBS_ID")[1]
  println("OBS_ID=$obsid")
  println("order=$order")
  exposure_time_sec = float(read_key(fff[1], "RDCDTIME")[1])
  println("Exposure time=$exposure_time_sec seconds")
  close(fff)
  println("---------------------------------------")
  if order==-1
      gorder="m1"
  elseif order==-2
      gorder="m2"
  else
      println("Grating order not calibrated")
  end
  

  srcphafile = target * "_" * obsid * "_" * uvit_detector * "_" * uvit_grating * "_" * gorder * "_"  * "crossdisp" * string(cross_disp_width_pixels) *  "pix_" * "xax_disp_" * string(angle_xaxis_disp_deg) * "deg_src.pha"
  bgdphafile = target * "_" * obsid * "_" * uvit_detector * "_" * uvit_grating * "_" * gorder * "_" * "crossdisp" * string(cross_disp_width_pixels) *  "pix_" * "xax_disp_" * string(angle_xaxis_disp_deg) * "deg_bgd.pha"
	#Extract 1d count spectrum
   	(pixels, src_count_spec) = fuv_grating1_count_spec(fuv_grating1_image_file, ds9srcregfile,  order=order, cross_disp_width_pixels = cross_disp_width_pixels, angle_xaxis_disp_deg=angle_xaxis_disp_deg, rate = false)
   	(pixels_bgd, bgd_count_spec) = fuv_grating1_count_spec(fuv_grating1_image_file,  ds9bgdregfile, order=order, cross_disp_width_pixels = cross_disp_width_pixels, angle_xaxis_disp_deg=angle_xaxis_disp_deg, rate = false)

   	src_count_spec_vals = Measurements.value.(src_count_spec)
   	bgd_count_spec_vals = Measurements.value.(bgd_count_spec)
  # Define spectral channels
   	pha_channels = convert.(Int64, LinearIndices(src_count_spec))
	# Write phafiles

    println("Writing source and background PHA files..")
   	src_pha_file_written = write_uvit_grating_phafile(uvit_detector, uvit_grating, pha_channels, reverse(src_count_spec_vals), exposure_time_sec; phafile = srcphafile)
   	bgd_pha_file_written = write_uvit_grating_phafile(uvit_detector, uvit_grating, pha_channels, reverse(bgd_count_spec_vals), exposure_time_sec; phafile = bgdphafile)

	# Find correct response file
	respdir = joinpath(dirname(dirname(pathof(UVITTools))), "caldata")
	if  order==-2
			rmffile=joinpath(respdir, "fuv_grating1_m2_12nov22.rmf")
			println("Using respfile", rmffile)
	elseif  order==-1
			rmffile=joinpath(respdir, "fuv_grating1_m1_3oct19.rmf")
			println("Using respfile", rmffile)
	else
		print("Detector/Grating not recognised, see http://uvit.iiap.res.in/Instrument")
		print("rmf/arf filenames not updated in the PHA header.")
		rmffile="NONE"
	#	arffile="NONE"
	end
	println("Using $rmffile")
	f=fits_open_file(srcphafile, +1)
	fits_movabs_hdu(f,2)
	fits_update_key(f,"BACKFILE",bgdphafile,"Background pha file")
	fits_update_key(f,"RESPFILE",rmffile,"Response matrix with effective area")
	fits_close_file(f)

		return src_pha_file_written, bgd_pha_file_written
end
